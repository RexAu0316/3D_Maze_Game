window.initGame = (React, assetsUrl) => {
  const { useEffect, useRef } = React;
  const { useFrame, useThree } = window.ReactThreeFiber;
  const THREE = window.THREE;

  const MazeWall = ({ position, scale }) => {
    return React.createElement('mesh', {
      position: position,
      scale: scale,
      geometry: new THREE.BoxGeometry(1, 1, 1),
      material: new THREE.MeshStandardMaterial({ color: 'gray' }),
      className: 'maze-wall'
    });
  };

  const Coin = ({ position }) => {
    return React.createElement('mesh', {
      position: position,
      geometry: new THREE.CircleGeometry(0.5, 32),
      material: new THREE.MeshStandardMaterial({ color: 'gold', side: THREE.DoubleSide }),
      rotation: [0, 0, 0]
    });
  };

  function Player({ wallBoxes }) {
    const playerRef = useRef();
    const speed = 0.1;
    const keys = useRef({});

    useEffect(() => {
      const handleKeyDown = (event) => {
        keys.current[event.key] = true;
      };

      const handleKeyUp = (event) => {
        keys.current[event.key] = false;
      };

      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
      };
    }, []);

    const checkCollision = (nextPosition) => {
      const playerBox = new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(...nextPosition),
        new THREE.Vector3(0.5, 1, 0.5)
      );

      return wallBoxes.some(wallBox => playerBox.intersectsBox(wallBox));
    };

    useFrame(() => {
      if (playerRef.current) {
        const direction = new THREE.Vector3();
        if (keys.current['ArrowUp']) direction.z -= speed;
        if (keys.current['ArrowDown']) direction.z += speed;
        if (keys.current['ArrowLeft']) direction.x -= speed;
        if (keys.current['ArrowRight']) direction.x += speed;

        const nextPosition = [
          playerRef.current.position.x + direction.x,
          playerRef.current.position.y,
          playerRef.current.position.z + direction.z,
        ];

        if (!checkCollision(nextPosition)) {
          playerRef.current.position.set(nextPosition[0], nextPosition[1], nextPosition[2]);
        }
      }
    });

    return React.createElement('mesh', {
      ref: playerRef,
      position: [8.5, 0.5, -8.5],
      geometry: new THREE.BoxGeometry(0.5, 1, 0.5),
      material: new THREE.MeshStandardMaterial({ color: 'blue' })
    });
  }

  function ThirdPersonCamera({ playerRef }) {
  const { camera } = useThree();
  const offset = new THREE.Vector3(0, 2, -5); // Change this to control the camera position
  const rotationSpeed = 0.1; // Speed at which the camera rotates to follow the player

  useFrame(() => {
    if (playerRef.current) {
      const playerPosition = playerRef.current.position;

      // Set camera position behind the player
      camera.position.copy(playerPosition).add(offset);

      // Ensure the camera looks at the player
      camera.lookAt(playerPosition);

      // Optional: Smoothly interpolate camera rotation
      const targetRotation = new THREE.Vector3(0, playerRef.current.rotation.y, 0);
      camera.rotation.x += (targetRotation.x - camera.rotation.x) * rotationSpeed;
      camera.rotation.y += (targetRotation.y - camera.rotation.y) * rotationSpeed;
    }
  });

  return null;
}

    useFrame(() => {
      if (playerRef.current) {
        const playerPosition = playerRef.current.position;
        camera.position.copy(playerPosition).add(offset);
        camera.lookAt(playerPosition);

        // Rotate the camera based on mouse movement
        const rotationSpeed = 0.002; // Adjust rotation speed
        const yaw = (mouseX / window.innerWidth - 0.5) * Math.PI; // X rotation
        const pitch = (mouseY / window.innerHeight - 0.5) * Math.PI; // Y rotation

        camera.rotation.set(pitch, yaw, 0); // Set camera rotation
      }
    });

    return null;
  }

  function Maze() {
    const wallHeight = 1;
    const mazeLayout = [
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
      [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1],
      [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
      [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
      [1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
      [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
      [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1],
      [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1],
      [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
      [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
      [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
      [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1],
      [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
      [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],

    ];

    const wallPositions = [];
    const wallBoxes = [];

    mazeLayout.forEach((row, rowIndex) => {
      row.forEach((cell, colIndex) => {
        if (cell === 1) {
          const position = [
            colIndex - mazeLayout[0].length / 2 + 0.5,
            wallHeight / 2,
            rowIndex - mazeLayout.length / 2 + 0.5,
          ];
          wallPositions.push({
            position: position,
            scale: [1, wallHeight, 1]
          });

          const wallBox = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(...position),
            new THREE.Vector3(1, wallHeight, 1)
          );
          wallBoxes.push(wallBox);
        }
      });
    });

    return React.createElement(
      React.Fragment,
      null,
      wallPositions.map((wall, index) =>
        React.createElement(MazeWall, {
          key: index,
          position: wall.position,
          scale: wall.scale
        })
      ),
      React.createElement(Player, { wallBoxes })
    );
  }

   function MazeRunnerGame() {
    const playerRef = useRef(); // Reference to the player

    return React.createElement(
      React.Fragment,
      null,
      React.createElement(ThirdPersonCamera, { playerRef }), // Add third-person camera
      React.createElement('ambientLight', { intensity: 0.5 }),
      React.createElement('pointLight', { position: [10, 10, 10] }),
      React.createElement(Maze)
    );
  }

  // Render the game
  const rootElement = document.getElementById('game-root'); // Ensure you have a div with this ID in your HTML
  ReactDOM.render(React.createElement(MazeRunnerGame), rootElement);
};

console.log('3D Maze Runner game script loaded');
